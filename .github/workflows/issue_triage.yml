name: Intelligent Issue Triage

on:
  issues:
    types: [opened, reopened]

jobs:
  triage:
    runs-on: ubuntu-latest
    permissions:
      issues: write # Permite que el workflow escriba en las issues (ej. añadir etiquetas)

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.x' # Usa la versión de Python que prefieras, 3.x es una buena opción general

    - name: Install Gemini CLI
      run: pip install gemini-cli

    - name: Install jq
      run: sudo apt-get install -y jq

    - name: Get Issue Details
      id: get_issue
      run: |
        ISSUE_TITLE="${{ github.event.issue.title }}"
        ISSUE_BODY="${{ github.event.issue.body }}"
        ISSUE_NUMBER="${{ github.event.issue.number }}"
        echo "Issue Title: $ISSUE_TITLE"
        echo "Issue Body: $ISSUE_BODY"
        echo "Issue Number: $ISSUE_NUMBER"
        echo "issue_title=$ISSUE_TITLE" >> $GITHUB_OUTPUT
        echo "issue_number=$ISSUE_NUMBER" >> $GITHUB_OUTPUT
        echo "issue_body<<EOF" >> $GITHUB_OUTPUT
        echo "$ISSUE_BODY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Call Gemini CLI for Triage
      id: gemini_triage
      env:
        GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
      run: |
        ISSUE_TITLE="${{ steps.get_issue.outputs.issue_title }}"

        # Llama al script para construir el prompt y guardarlo en un archivo temporal
        PROMPT_FILE="prompt_${GITHUB_RUN_ID}.txt"
        bash backend/scripts/build_gemini_prompt.sh "${ISSUE_TITLE}" "${{ steps.get_issue.outputs.issue_body }}" "${PROMPT_FILE}"

        # Llama a Gemini CLI y parsea la respuesta JSON
        GEMINI_RESPONSE=$(gemini-cli --model gemini-pro < "${PROMPT_FILE}")
        echo "Raw Gemini Response: ${GEMINI_RESPONSE}"

        # Limpia el archivo temporal
        rm "${PROMPT_FILE}"

        # Extrae el contenido JSON de la respuesta de Gemini
        # Asumimos que la respuesta de Gemini es un JSON válido directamente o está dentro de un bloque de código
        # Si Gemini envuelve el JSON en markdown, necesitamos extraerlo
        JSON_OUTPUT=$(echo "${GEMINI_RESPONSE}" | sed 's/```json//g' | sed 's/```//g' | jq -c .)

        if [ -z "$JSON_OUTPUT" ]; then
          echo "Error: Gemini did not return valid JSON." >&2
          exit 1
        fi

        SUGGESTED_LABEL=$(echo "${JSON_OUTPUT}" | jq -r '.label')
        SUGGESTED_PRIORITY=$(echo "${JSON_OUTPUT}" | jq -r '.priority')

        echo "Suggested Label: ${SUGGESTED_LABEL}"
        echo "Suggested Priority: ${SUGGESTED_PRIORITY}"

        echo "suggested_label=${SUGGESTED_LABEL}" >> $GITHUB_OUTPUT
        echo "suggested_priority=${SUGGESTED_PRIORITY}" >> $GITHUB_OUTPUT


    - name: Update Issue with Triage Results
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Token proporcionado automáticamente por GitHub Actions
      run: |
        ISSUE_NUMBER="${{ steps.get_issue.outputs.issue_number }}"
        SUGGESTED_LABEL="${{ steps.gemini_triage.outputs.suggested_label }}"
        SUGGESTED_PRIORITY="${{ steps.gemini_triage.outputs.suggested_priority }}"

        echo "Adding label '$SUGGESTED_LABEL' to issue #$ISSUE_NUMBER"
        gh issue edit $ISSUE_NUMBER --add-label "$SUGGESTED_LABEL" --repo ${{ github.repository }}

        echo "Adding comment with suggested priority '$SUGGESTED_PRIORITY' to issue #$ISSUE_NUMBER" 
        gh issue comment $ISSUE_NUMBER --body "Gemini Triage Suggestion: Priority: $SUGGESTED_PRIORITY" --repo ${{ github.repository }}
